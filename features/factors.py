import pandas as pd
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin

#TransformerMixin isolates each factor so I can test and extend one at a time

class MomemntumTransformer(BaseEstimator, TransformerMixin):
    """
    Computes T-day simple momentum as the percentage change over a specified window.
    (P-t / P_{t-window}) -1
    """
    def __init__(self, window: int = 20, price_col: str = "Close"):
        self.window = window
        self.price_col = price_col

    def fit(self, X: pd.DataFrame, y=None):
        return self

    def transform(self, X: pd.DataFrame) -> pd.DataFrame:
        #Grab the series, whether X[self.price_col] gives a Series or single-col DataFrame
        series = X[self.price_col]
        if isinstance(series, pd.DataFrame):
            if series.shape[1] == 1: #ie is a single-column DataFrame
                series = series.iloc[:, 0] # convert to Series
            else:
                raise ValueError(
                    f"MomentumTransformer expected one column for '{self.price_col}', "
                    f"but got {series.shape[1]} columns."
                )
            mom = series.pct_change(self.window)  # always return a DataFrame
            return pd.DataFrame({f"mom_{self.window}": mom}, index=X.index)
    
    def get_feature_names_out(self, input_features=None) -> np.ndarray:
        """
        Returns the name of the feature generated by this transformer.
        """
        return np.array([f"mom_{self.window}"])
        
class ZScoreTransformer(BaseEstimator, TransformerMixin):
    """Rolling z-score over window days of return """
    def __init__(self, window: int = 20, price_col: str = "Close"):
        self.window = window
        self.price_col = price_col

    def fit(self, X: pd.DataFrame, y=None):
        return self

    #Z=(returns - rolling_mean) / rolling_std
    #This is just a standardization of the returns
    #It measures how many standard deviations the current return is from the mean return over the window
    def transform(self, X: pd.DataFrame) -> pd.DataFrame:
        series = X[self.price_col]
        if isinstance(series, pd.DataFrame):
            if series.shape[1] == 1:
                series = series.iloc[:, 0]
            else:
                raise ValueError(
                    f"ZScoreTransformer expected one column for '{self.price_col}', "
                    f"but got {series.shape[1]} columns."
                )
            returns = series.pct_change()  # Calculate returns
            rolling_mean = returns.rolling(self.window).mean()
            rolling_std = returns.rolling(self.window).std()
            z_score = (returns - rolling_mean) / rolling_std
            return pd.DataFrame({f"zscore_{self.window}": z_score}, index=X.index)
    
    def get_feature_names_out(self, input_features=None) -> np.ndarray:
        """
        Returns the name of the feature generated by this transformer.
        """
        return np.array([f"zscore_{self.window}"])

class MovingAverageTransformer(BaseEstimator, TransformerMixin):
    """
    Computes a moving average for a given window size.
    """
    def __init__(self, window: int = 20, column: str = "Close"):
        self.window = window
        self.column = column

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X = X.copy()
        X[f"ma_{self.window}"] = X[self.column].rolling(self.window).mean()
        return X

class VolatilityTransformer(BaseEstimator, TransformerMixin):
    """
    Computes rolling volatility (standard deviation) for a given window size.
    """
    def __init__(self, window: int = 20, column: str = "Close"):
        self.window = window
        self.column = column

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X = X.copy()
        X[f"vol_{self.window}"] = X[self.column].rolling(self.window).std()
        return X
